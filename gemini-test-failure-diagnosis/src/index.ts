import * as core from "@actions/core";
import * as fs from "fs";
import * as path from "path";
import {
  createGeminiModel,
  generateContent,
  getOctokitClient,
  getRepoContext,
  getPullRequest,
  getFileContent,
  postComment,
} from "@gemini-actions/shared";

async function run(): Promise<void> {
  try {
    const prNumber = parseInt(core.getInput("pr_number", { required: true }), 10);
    const testOutputPath = core.getInput("test_output", { required: true });
    const geminiApiKey = core.getInput("gemini_api_key", { required: true });
    const githubToken = core.getInput("github_token", { required: true });
    const modelName = core.getInput("model") || "gemini-2.0-flash";

    const octokit = getOctokitClient(githubToken);
    const { owner, repo } = getRepoContext();
    const model = createGeminiModel(geminiApiKey, modelName);

    core.info(`Diagnosing test failures for PR #${prNumber}...`);

    // 1. Get PR details and diff
    const pr = await getPullRequest(octokit, owner, repo, prNumber);
    core.info(`PR: ${pr.title} (${pr.files.length} files changed)`);

    // 2. Read test output
    let testOutput: string;
    const resolvedPath = path.resolve(testOutputPath);

    if (fs.existsSync(resolvedPath)) {
      testOutput = fs.readFileSync(resolvedPath, "utf-8");
      core.info(`Read test output from ${resolvedPath} (${testOutput.length} chars)`);
    } else {
      // Try to find it as a workspace artifact
      const workspacePath = path.join(
        process.env.GITHUB_WORKSPACE || ".",
        testOutputPath,
      );
      if (fs.existsSync(workspacePath)) {
        testOutput = fs.readFileSync(workspacePath, "utf-8");
        core.info(`Read test output from ${workspacePath}`);
      } else {
        throw new Error(
          `Test output not found at ${resolvedPath} or ${workspacePath}`,
        );
      }
    }

    // Truncate very long test output to fit in the prompt
    const maxTestOutput = 15000;
    if (testOutput.length > maxTestOutput) {
      testOutput =
        testOutput.slice(0, maxTestOutput) +
        `\n\n... [truncated ${testOutput.length - maxTestOutput} characters]`;
    }

    // 3. Extract failing test file names from the output
    const testFilePatterns = extractTestFilePaths(testOutput);
    core.info(`Detected test files in output: ${testFilePatterns.join(", ") || "none"}`);

    // 4. Fetch failing test source code (if identifiable)
    const testSources: Record<string, string> = {};
    for (const testFile of testFilePatterns.slice(0, 5)) {
      try {
        const content = await getFileContent(
          octokit,
          owner,
          repo,
          testFile,
          pr.head.ref,
        );
        testSources[testFile] = content;
      } catch {
        core.debug(`Could not fetch test file: ${testFile}`);
      }
    }

    // 5. Send to Gemini for diagnosis
    const prompt = `You are a senior software engineer diagnosing test failures on a pull request.

**PR Title:** ${pr.title}
**PR Description:** ${pr.body ?? "No description."}

**PR Diff (changes made):**
\`\`\`diff
${pr.files
  .map(
    (f) =>
      `--- ${f.filename} ---\n${f.patch ?? "(binary or no diff)"}`,
  )
  .join("\n\n")
  .slice(0, 15000)}
\`\`\`

**Test Output (failures):**
\`\`\`
${testOutput}
\`\`\`

${
  Object.keys(testSources).length > 0
    ? `**Failing Test Source Code:**
${Object.entries(testSources)
  .map(([path, content]) => `--- ${path} ---\n\`\`\`\n${content.slice(0, 5000)}\n\`\`\``)
  .join("\n\n")}`
    : ""
}

Provide a diagnosis that includes:

1. **Root Cause**: Explain the causal link between the PR changes and the test failures. What specific change caused what specific test to fail, and why?
2. **Affected Tests**: List each failing test and explain why it fails.
3. **Suggested Fix**: Provide specific, actionable fix suggestions. Include code snippets where helpful. Indicate whether the fix should be in the source code or the tests.

Format your response as clear, structured markdown.`;

    const diagnosis = await generateContent(model, prompt);

    // 6. Post the diagnosis as a comment
    const comment = `## Gemini Test Failure Diagnosis

${diagnosis}

---
*Analyzed ${pr.files.length} changed file(s) and ${testFilePatterns.length} test file(s) â€” Generated by [gemini-test-failure-diagnosis](https://github.com/dortort/gemini-actions)*`;

    await postComment(octokit, owner, repo, prNumber, comment);
    core.info("Test failure diagnosis posted");
  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed("An unexpected error occurred");
    }
  }
}

function extractTestFilePaths(testOutput: string): string[] {
  const paths = new Set<string>();

  // Common patterns for test file paths in output
  const patterns = [
    // Jest/Vitest: FAIL src/tests/foo.test.ts
    /(?:FAIL|FAILED)\s+(\S+\.(?:test|spec)\.\w+)/g,
    // pytest: FAILED tests/test_foo.py::test_bar
    /FAILED\s+(\S+\.py)::/g,
    // Go: --- FAIL: TestFoo (path/to/test.go:42)
    /\(([^)]+_test\.go):\d+\)/g,
    // Generic file paths with test in the name
    /(\S+(?:test|spec)\S*\.(?:ts|js|tsx|jsx|py|go|java|rb))/gi,
  ];

  for (const pattern of patterns) {
    let match;
    while ((match = pattern.exec(testOutput)) !== null) {
      const filePath = match[1].replace(/^\.\//, "");
      if (!filePath.includes("node_modules")) {
        paths.add(filePath);
      }
    }
  }

  return [...paths];
}

run();
